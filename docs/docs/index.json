[
{
	"uri": "/docs/devops/mysql/",
	"title": "Mysql常用用法总结",
	"tags": [],
	"description": "",
	"content": "    版本 日期 状态 修订人 摘要     V1.0 2016-03-28 创建 HunterFu 创建文档    在日常工作中，会简单的使用一下mysql,故对常见命令操作总结一下，常用方式如下\nmysqldump 命令的使用  备份和导出数据库\nmysqldump -h database_ip -u Username -p --opt databasename \u0026gt; backup-file.sql  只导出数据库表结构\nmysqldump -h database_ip -d -u Username -p databasename \u0026gt;database_structure.sql  只导出数据库中的某个表\nmysqldump --opt --add-drop-table -u Username -p databasename tablename \u0026gt; dump.sql  如果不想手工输入密码 请使用--password 参数\nmysqldump -h database_ip -u Username --password=123456 --opt databasename \u0026gt; backup-file.sql mysqldump -h database_ip -d -u Username --password=123456 databasename \u0026gt;database_structure.sql  修改root用户密码\nmysqladmin -u root password \u0026quot;123456\u0026quot;   mysql 命令使用  将查询结果保存到文件\nselect title from book into outfile '/tmp/outfile.txt';  查找表中多余的重复记录，重复记录是根据某个字段（peopleId）来判断\nselect * from people where peopleId in (select peopleId from people group by peopleId having count(peopleId) \u0026gt; 1);  查询表中不重复记录(排除重复记录)\nselect * from phome_ecms_wma where title in (select distinct title from phome_ecms_wma);  删除表中重复记录,重复记录是根据某个字段（title）来判断\nselect *,count(distinct title) INTO OUTFILE '/tmp/table.bak' from phome_ecms_wma group by title; delete from phome_ecms_wma; LOAD DATA INFILE '/tmp/table.bak' REPLACE INTO TABLE phome_ecms_wma character set utf8;  随机选取记录\nmysql\u0026gt; SELECT *FROM url ORDER BY RAND() LIMIT 5;  查询数据库当前编码\nmysql\u0026gt; show variables like \u0026quot;character_set%\u0026quot;;  修改表字段类型\nmysql\u0026gt; alter table table_name change last_action last_action datetime NOT NULL default '0000-00-00 00:00:00';  给表添加一个新字段\nmysql\u0026gt; ALTER TABLE host ADD ks_mac VARCHAR(100);  从表中删除一个字段\nmysql\u0026gt; ALTER TABLE table_name DROP field_name;  重命名表\nmysql\u0026gt;alter table t1 rename t2;  给字段加索引\nmysql\u0026gt; alter table tablename add index 索引名 (字段名1[，字段名2 …]); mysql\u0026gt; alter table tablename add index emp_name (name);  加主关键字的索引\nmysql\u0026gt; alter table tablename add primary key(id);  加唯一限制条件的索引\nmysql\u0026gt; alter table tablename add unique emp_name2(cardnumber);  删除某个索引\nmysql\u0026gt;alter table tablename drop index emp_name;  远程访问mysql 设置(单独一个IP)\nmysql\u0026gt; CREATE DATABASE IF NOT EXISTS database_test; mysql\u0026gt; GRANT ALL PRIVILEGES ON database_test.* to root@192.168.1.9 IDENTIFIED BY '123456'; mysql\u0026gt; FLUSH PRIVILEGES;  授权远程访问(一个网段)\nmysql\u0026gt; grant all privileges on *.* to root@'192.168.124.%' identified by '123456'; mysql\u0026gt; FLUSH PRIVILEGES;   shell 命令中 mysql 使用 mysql -u root -p -e 'CREATE DATABASE IF NOT EXISTS database_test;' mysql -u root -p -e \u0026quot;GRANT ALL PRIVILEGES ON database_test.* to root@'%' IDENTIFIED BY '123456';\u0026quot;  "
},
{
	"uri": "/docs/cloudstack/",
	"title": "私有云",
	"tags": [],
	"description": "",
	"content": " 私有云 CloudStack CloudStack 本分类主要讲述 cloudstack 相关配置等实践\n"
},
{
	"uri": "/docs/devops/python_tips/",
	"title": "Python脚本知识总结",
	"tags": [],
	"description": "",
	"content": "    版本 日期 状态 修订人 摘要     V1.0 2016-03-28 创建 HunterFu 创建文档   V1.1 2017-08-07 修订 HunterFu 增加 指定占位符宽度(左对齐)    数据对象持久化 在某些时候，需要将数据对象的内容保存下来，方便下次程序启动时读取，这个就需要将对象持久化，请看如下例子\nimport pickle # create the test dictionary before_d = {} before_d[1]=\u0026quot;Name 1\u0026quot; before_d[2]=\u0026quot;Name 2\u0026quot; before_d[3]=\u0026quot;Name 3\u0026quot; # pickle dump the dictionary fout = open(\u0026quot;dict1.dat\u0026quot;, \u0026quot;w\u0026quot;) pickle.dump(before_d, fout, protocol=0) fout.close() # pickle load the dictionary fin = open(\u0026quot;dict1.dat\u0026quot;, \u0026quot;r\u0026quot;) after_d = pickle.load(fin) fin.close() print( before_d ) # {1: 'Name 1', 2: 'Name 2', 3: 'Name 3'} print( after_d ) # {1: 'Name 1', 2: 'Name 2', 3: 'Name 3'}  可以看出，我们将数据对象内容以文件的方式保存，可以作一些简单的cache处理，尤其是在写一些比较小的程序时，非常有用\n正则表达式替换 目标: 将字符串line中的 overview.gif 替换成其他字符串\n\u0026gt;\u0026gt;\u0026gt; line = '\u0026lt;IMG ALIGN=\u0026quot;middle\u0026quot; SRC=\u0026quot;overview.gif\u0026quot; BORDER=\u0026quot;0\u0026quot; ALT=\u0026quot;\u0026quot;\u0026gt;' \u0026gt;\u0026gt;\u0026gt; mo=re.compile(r'(?\u0026lt;=SRC=)\u0026quot;([\\w+\\.]+)\u0026quot;',re.I) \u0026gt;\u0026gt;\u0026gt; mo.sub(r'\u0026quot;\\1****\u0026quot;',line) '\u0026lt;IMG ALIGN=\u0026quot;middle\u0026quot; SRC=\u0026quot;cdn_overview.gif****\u0026quot; BORDER=\u0026quot;0\u0026quot; ALT=\u0026quot;\u0026quot;\u0026gt;' \u0026gt;\u0026gt;\u0026gt; mo.sub(r'replace_str_\\1',line) '\u0026lt;IMG ALIGN=\u0026quot;middle\u0026quot; SRC=replace_str_overview.gif BORDER=\u0026quot;0\u0026quot; ALT=\u0026quot;\u0026quot;\u0026gt;' \u0026gt;\u0026gt;\u0026gt; mo.sub(r'\u0026quot;testetstset\u0026quot;',line) '\u0026lt;IMG ALIGN=\u0026quot;middle\u0026quot; SRC=\u0026quot;testetstset\u0026quot; BORDER=\u0026quot;0\u0026quot; ALT=\u0026quot;\u0026quot;\u0026gt;'  注意: 其中 \\1 是匹配到的数据，可以通过这样的方式直接引用\n遍历目录方法 在某些时候，我们需要遍历某个目录找出特定的文件列表，可以通过os.walk方法来遍历,非常方便\nimport os fileList = [] rootdir = \u0026quot;/tmp\u0026quot; for root, subFolders, files in os.walk(rootdir): if '.svn' in subFolders: subFolders.remove('.svn') # 排除特定目录 for file in files: if file.find(\u0026quot;.t2t\u0026quot;) != -1:\t# 查找特定扩展名的文件 file_dir_path = os.path.join(root,file) fileList.append(file_dir_path) print fileList  列表按列排序(list sort) 如果列表的每个元素都是一个元组(tuple),我们要根据元组的某列来排序的化，可参考如下方法\n下面例子我们是根据元组的第2列和第3列数据来排序的,而且是倒序(reverse=True)\n\u0026gt;\u0026gt;\u0026gt; a = [('2011-03-17', '2.26', 6429600, '0.0'), ('2011-03-16', '2.26', 12036900, '-3.0'), ('2011-03-15', '2.33', 15615500,'-19.1')] \u0026gt;\u0026gt;\u0026gt; print a[0][0] 2011-03-17 \u0026gt;\u0026gt;\u0026gt; b = sorted(a, key=lambda result: result[1],reverse=True) \u0026gt;\u0026gt;\u0026gt; print b [('2011-03-15', '2.33', 15615500, '-19.1'), ('2011-03-17', '2.26', 6429600, '0.0'), ('2011-03-16', '2.26', 12036900, '-3.0')] \u0026gt;\u0026gt;\u0026gt; c = sorted(a, key=lambda result: result[2],reverse=True) \u0026gt;\u0026gt;\u0026gt; print c [('2011-03-15', '2.33', 15615500, '-19.1'), ('2011-03-16', '2.26', 12036900, '-3.0'), ('2011-03-17', '2.26', 6429600, '0.0')]  列表去重(list uniq) 有时候需要将list中重复的元素删除，就要使用如下方法\n\u0026gt;\u0026gt;\u0026gt; lst= [(1,'sss'),(2,'fsdf'),(1,'sss'),(3,'fd')] \u0026gt;\u0026gt;\u0026gt; set(lst) set([(2, 'fsdf'), (3, 'fd'), (1, 'sss')]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; lst = [1, 1, 3, 4, 4, 5, 6, 7, 6] \u0026gt;\u0026gt;\u0026gt; set(lst) set([1, 3, 4, 5, 6, 7])  字典排序(dict sort) 一般来说，我们都是根据字典的key来进行排序，但是我们如果想根据字典的value值来排序，就使用如下方法\n\u0026gt;\u0026gt;\u0026gt; from operator import itemgetter \u0026gt;\u0026gt;\u0026gt; aa = {\u0026quot;a\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;sss\u0026quot;:\u0026quot;2\u0026quot;,\u0026quot;ffdf\u0026quot;:'5',\u0026quot;ffff2\u0026quot;:'3'} \u0026gt;\u0026gt;\u0026gt; sort_aa = sorted(aa.items(),key=itemgetter(1)) \u0026gt;\u0026gt;\u0026gt; sort_aa [('a', '1'), ('sss', '2'), ('ffff2', '3'), ('ffdf', '5')]  从上面的运行结果看到，按照字典的value值进行排序的\n字典,列表,字符串互转  以下是生成数据库连接字符串,从字典转换到字符串\n\u0026gt;\u0026gt;\u0026gt; params = {\u0026quot;server\u0026quot;:\u0026quot;mpilgrim\u0026quot;, \u0026quot;database\u0026quot;:\u0026quot;master\u0026quot;, \u0026quot;uid\u0026quot;:\u0026quot;sa\u0026quot;, \u0026quot;pwd\u0026quot;:\u0026quot;secret\u0026quot;} \u0026gt;\u0026gt;\u0026gt; [\u0026quot;%s=%s\u0026quot; % (k, v) for k, v in params.items()] ['server=mpilgrim', 'uid=sa', 'database=master', 'pwd=secret'] \u0026gt;\u0026gt;\u0026gt; \u0026quot;;\u0026quot;.join([\u0026quot;%s=%s\u0026quot; % (k, v) for k, v in params.items()]) 'server=mpilgrim;uid=sa;database=master;pwd=secret'  下面的例子 是将字符串转化为字典\n\u0026gt;\u0026gt;\u0026gt; a = 'server=mpilgrim;uid=sa;database=master;pwd=secret' \u0026gt;\u0026gt;\u0026gt; aa = {} \u0026gt;\u0026gt;\u0026gt; for i in a.split(';'):aa[i.split('=',1)[0]] = i.split('=',1)[1] ... \u0026gt;\u0026gt;\u0026gt; aa {'pwd': 'secret', 'database': 'master', 'uid': 'sa', 'server': 'mpilgrim'}   时间对象操作  将时间对象转换成字符串\n\u0026gt;\u0026gt;\u0026gt; import datetime \u0026gt;\u0026gt;\u0026gt; datetime.datetime.now().strftime(\u0026quot;%Y-%m-%d %H:%M\u0026quot;) '2011-01-20 14:05'  时间大小比较\n\u0026gt;\u0026gt;\u0026gt; import time \u0026gt;\u0026gt;\u0026gt; t1 = time.strptime('2011-01-20 14:05',\u0026quot;%Y-%m-%d %H:%M\u0026quot;) \u0026gt;\u0026gt;\u0026gt; t2 = time.strptime('2011-01-20 16:05',\u0026quot;%Y-%m-%d %H:%M\u0026quot;) \u0026gt;\u0026gt;\u0026gt; t1 \u0026gt; t2 False \u0026gt;\u0026gt;\u0026gt; t1 \u0026lt; t2 True  时间差值计算,计算8小时前的时间\n\u0026gt;\u0026gt;\u0026gt; datetime.datetime.now().strftime(\u0026quot;%Y-%m-%d %H:%M\u0026quot;) '2011-01-20 15:02' \u0026gt;\u0026gt;\u0026gt; (datetime.datetime.now() - datetime.timedelta(hours=8)).strftime(\u0026quot;%Y-%m-%d %H:%M\u0026quot;) '2011-01-20 07:03'  将字符串转换成时间对象\n\u0026gt;\u0026gt;\u0026gt; endtime=datetime.datetime.strptime('20100701',\u0026quot;%Y%m%d\u0026quot;) \u0026gt;\u0026gt;\u0026gt; type(endtime) \u0026lt;type 'datetime.datetime'\u0026gt; \u0026gt;\u0026gt;\u0026gt; print endtime 2010-07-01 00:00:00 \u0026gt;\u0026gt;\u0026gt;  将从 1970-01-01 00:00:00 UTC 到现在的秒数，格式化输出\n\u0026gt;\u0026gt;\u0026gt; import time \u0026gt;\u0026gt;\u0026gt; a = 1302153828 \u0026gt;\u0026gt;\u0026gt; time.strftime(\u0026quot;%Y-%m-%d %H:%M:%S\u0026quot;,time.localtime(a)) '2011-04-07 13:23:48'  将日期转换成秒数\n\u0026gt;\u0026gt;\u0026gt; endtime=datetime.datetime.strptime('20100701',\u0026quot;%Y%m%d\u0026quot;) \u0026gt;\u0026gt;\u0026gt; time.mktime(endtime.timetuple()) 1277913600.0  strptime | strftime 支持的时间格式化列表\n     格式化字符 意义     %a 星期几的简写 Weekday name, abbr.   %A 星期几的全称 Weekday name, full   %b 月分的简写 Month name, abbr.   %B 月份的全称 Month name, full   %c 标准的日期的时间串 Complete date and time representation   %d 十进制表示的每月的第几天 Day of the month   %H 24小时制的小时 Hour (24-hour clock)   %I 12小时制的小时 Hour (12-hour clock)   %j 十进制表示的每年的第几天 Day of the year   %m 十进制表示的月份 Month number   %M 十时制表示的分钟数 Minute number   %s seconds since 00:00:00 1970-01-01 UTC (a GNU extension)   %S 十进制的秒数 Second number   %U 第年的第几周，把星期日做为第一天（值从0到53）Week number (Sunday first weekday)   %w 十进制表示的星期几（值从0到6，星期天为0）weekday number   %W 每年的第几周，把星期一做为第一天（值从0到53） Week number (Monday first weekday)   %x 标准的日期串 Complete date representation (e.g. 13/01/08)   %X 标准的时间串 Complete time representation (e.g. 17:02:10)   %y 不带世纪的十进制年份（值从0到99）Year number within century   %Y 带世纪部分的十制年份 Year number   %Z 时区名称，如果不能得到时区名称则返回空字符。Name of time zone   %% 输出百分号    命令行参数解析(getopt) 通常在编写一些日运维脚本时，需要根据不同的条件，输入不同的命令行选项来实现不同的功能, 在Python中提供了getopt模块很好的实现了命令行参数的解析,下面距离说明。 请看如下程序:\n#!/usr/bin/env python # -*- coding: utf-8 -*- import sys,os,getopt def usage(): print ''' Usage: analyse_stock.py [options...] Options: -e : Exchange Name -c : User-Defined Category Name -f : Read stock info from file and save to db -d : delete from db by stock code -n : stock name -s : stock code -h : this help info test.py -s haha -n \u0026quot;HA Ha\u0026quot; ''' try: opts, args = getopt.getopt(sys.argv[1:],'he:c:f:d:n:s:') except getopt.GetoptError: usage() sys.exit() if len(opts) == 0: usage() sys.exit() for opt, arg in opts: if opt in ('-h', '--help'): usage() sys.exit() elif opt == '-d': print \u0026quot;del stock %s\u0026quot; % arg elif opt == '-f': print \u0026quot;read file %s\u0026quot; % arg elif opt == '-c': print \u0026quot;user-defined %s \u0026quot; % arg elif opt == '-e': print \u0026quot;Exchange Name %s\u0026quot; % arg elif opt == '-s': print \u0026quot;Stock code %s\u0026quot; % arg elif opt == '-n': print \u0026quot;Stock name %s\u0026quot; % arg sys.exit()  注意: 这里我们使用短格式分析串\u0026lsquo;he:c:f:d:n:s:\u0026rsquo;, 当一个选项只是表示开关状态时,即后面不带附加参数时,在分析串中写入选项字符\n当选项后面是带一个附加参数时，在分析串中写入选项字符同时后面加一个 : 冒号\n所以 \u0026lsquo;he:c:f:d:n:s:\u0026rsquo; 就表示 \u0026lsquo;h\u0026rsquo;是一个开关选项, \u0026lsquo;e:c:f:d:n:s:\u0026lsquo;则表示这些选项后面应该带一个参数.\nprint 格式化输出 格式化输出字符串  截取字符串输出,下面例子将只输出字符串的前3个字母\n\u0026gt;\u0026gt;\u0026gt; str=\u0026quot;abcdefg\u0026quot; \u0026gt;\u0026gt;\u0026gt; print \u0026quot;%.3s\u0026quot; % str abc  按固定宽度输出，不足使用空格补全,下面例子输出宽度为10\n\u0026gt;\u0026gt;\u0026gt; str=\u0026quot;abcdefg\u0026quot; \u0026gt;\u0026gt;\u0026gt; print \u0026quot;%10s\u0026quot; % str abcdefg  指定占位符宽度(左对齐)\n\u0026gt;\u0026gt;\u0026gt; print (\u0026quot;Name:%-10s Age:%-8d Height:%-8.2f\u0026quot;%(\u0026quot;Aviad\u0026quot;,25,1.83)) Name:Aviad Age:25 Height:1.83 \u0026gt;\u0026gt;\u0026gt;  截取字符串，按照固定宽度输出\n\u0026gt;\u0026gt;\u0026gt; str=\u0026quot;abcdefg\u0026quot; \u0026gt;\u0026gt;\u0026gt; print \u0026quot;%10.3s\u0026quot; % str abc  浮点类型数据位数保留\n\u0026gt;\u0026gt;\u0026gt; import fpformat \u0026gt;\u0026gt;\u0026gt; a= 0.0030000000005 \u0026gt;\u0026gt;\u0026gt; b=fpformat.fix(a,6) \u0026gt;\u0026gt;\u0026gt; print b 0.003000  对浮点数四舍五入,主要使用到round函数\n\u0026gt;\u0026gt;\u0026gt; from decimal import * \u0026gt;\u0026gt;\u0026gt; a =\u0026quot;2.26\u0026quot; \u0026gt;\u0026gt;\u0026gt; b =\u0026quot;2.29\u0026quot; \u0026gt;\u0026gt;\u0026gt; c = Decimal(a) - Decimal(b) \u0026gt;\u0026gt;\u0026gt; print c -0.03 \u0026gt;\u0026gt;\u0026gt; c / Decimal(a) * 100 Decimal('-1.327433628318584070796460177') \u0026gt;\u0026gt;\u0026gt; Decimal(str(round(c / Decimal(a) * 100, 2))) Decimal('-1.33') \u0026gt;\u0026gt;\u0026gt;   进制转换 有些时候需要作不同进制转换，可以参考下面的例子(%x 十六进制,%d 十进制,%o十进制)\n \u0026gt;\u0026gt;\u0026gt; num = 10 \u0026gt;\u0026gt;\u0026gt; print \u0026quot;Hex = %x,Dec = %d,Oct = %o\u0026quot; %(num,num,num) Hex = a,Dec = 10,Oct = 12  Python调用系统命令或者脚本  使用 os.system() 调用系统命令 , 程序中无法获得到输出和返回值\n\u0026gt;\u0026gt;\u0026gt; import os \u0026gt;\u0026gt;\u0026gt; os.system('ls -l /proc/cpuinfo') \u0026gt;\u0026gt;\u0026gt; os.system(\u0026quot;ls -l /proc/cpuinfo\u0026quot;) -r--r--r-- 1 root root 0 3月 29 16:53 /proc/cpuinfo 0  使用 os.popen() 调用系统命令, 程序中可以获得命令输出，但是不能得到执行的返回值\n\u0026gt;\u0026gt;\u0026gt; out = os.popen(\u0026quot;ls -l /proc/cpuinfo\u0026quot;) \u0026gt;\u0026gt;\u0026gt; print out.read() -r--r--r-- 1 root root 0 3月 29 16:59 /proc/cpuinfo \u0026gt;\u0026gt;\u0026gt;  使用 commands.getstatusoutput() 调用系统命令, 程序中可以获得命令输出和执行的返回值\n\u0026gt;\u0026gt;\u0026gt; import commands \u0026gt;\u0026gt;\u0026gt; commands.getstatusoutput('ls /bin/ls') (0, '/bin/ls') \u0026gt;\u0026gt;\u0026gt;   Python 捕获用户 Ctrl+C ,Ctrl+D 事件 有些时候，需要在程序中捕获用户键盘事件，比如ctrl+c退出，这样可以更好的安全退出程序\n try: do_some_func() except KeyboardInterrupt: print \u0026quot;User Press Ctrl+C,Exit\u0026quot; except EOFError: print \u0026quot;User Press Ctrl+D,Exit\u0026quot;  Python 读写文件  一次性读入文件到列表，速度较快，适用文件比较小的情况下\ntrack_file = \u0026quot;track_stock.conf\u0026quot; fd = open(track_file) content_list = fd.readlines() fd.close() for line in content_list: print line  逐行读入，速度较慢,适用没有足够内存读取整个文件(文件太大)\nfd = open(file_path) fd.seek(0) title = fd.readline() keyword = fd.readline() uuid = fd.readline() fd.close()   写文件 write 与 writelines 的区别\nFd.write(str) : 把str写到文件中，write()并不会在str后加上一个换行符\nFd.writelines(content) : 把content的内容全部写到文件中,原样写入，不会在每行后面加上任何东西\n Python 读取 YAML 配置文件 简单的配置文件范例 配置文件如下,一般YAML文件扩展名为.yaml:\n [root@localhost]# cat us-cdn.yaml templateName: \u0026quot;us-cdn\u0026quot; version: \u0026quot;0.1\u0026quot; actionsequence: - install - sync sync: - cmd: \u0026quot;svn export http://svn.test.com/\u0026quot; SuccessMsg: \u0026quot;OK\u0026quot; FailedMsg: \u0026quot;Run Cmd Error %s\u0026quot; install: - cmd: \u0026quot;yum install squid squid-script\u0026quot; SuccessMsg: \u0026quot;OK\u0026quot; FailedMsg: \u0026quot;Run Cmd Error %s\u0026quot;  从上面的配置文件来看，非常容易读懂和理解，层次关系也非常明了。\nPyYAML 模块来解析YAML配置文件 参考测试程序:\n [root@localhost]# cat test_yaml.py #!/usr/bin/env python # -*- coding: utf-8 -*- import os import yaml import sys from pprint import pprint base_dir = os.path.abspath(os.path.dirname(sys.argv[0])) configFile = \u0026quot;%s/%s\u0026quot; % (base_dir,\u0026quot;us-cdn.yaml\u0026quot;) stream = file(configFile, 'r') data = yaml.load(stream) pprint(data)  执行结果如下:\n [root@localhost]# python test_yaml.py {'actionsequence': ['install', 'sync'], 'install': [{'FailedMsg': 'Run Cmd Error %s', 'SuccessMsg': 'OK', 'cmd': 'yum install squid squid-script'}], 'sync': [{'FailedMsg': 'Run Cmd Error %s', 'SuccessMsg': 'OK', 'cmd': 'svn export http://svn.test.com/'}], 'templateName': 'us-cdn', 'version': '0.1'}  从执行结果可以看出,最终返回的是字典结构，你可以方便的引用。在写一些系统运维管理脚本的化，可以参考使用yaml格式的配置文件.\n常见问题 UnicodeDecodeError: \u0026lsquo;ascii\u0026rsquo; codec can\u0026rsquo;t decode byte 0xe8 in position 0: ordinal not in range(128) 程序加入如下3行，问题解决\nimport sys reload(sys) sys.setdefaultencoding('utf-8')  "
},
{
	"uri": "/docs/openshift/",
	"title": "容器云",
	"tags": [],
	"description": "",
	"content": " 容器云 OpenShift Origin OpenShift 本分类主要讲述 openshift origin 相关配置等实践\n"
},
{
	"uri": "/docs/devops/shell/",
	"title": "Shell脚本知识总结",
	"tags": [],
	"description": "",
	"content": "    版本 日期 状态 修订人 摘要     V1.0 2016-03-28 创建 HunterFu 创建文档    在日常系统管理工作中，需要编写脚本来完成特定的功能，编写shell脚本是一个基本功了！\n在编写的过程中，掌握一些常用的技巧和语法就可以完成大部分功能了，也就是2/8原则.\n单引号和双引号的区别 单引号与双引号的最大不同在于双引号仍然可以引用变量的内容，但单引号内仅是 普通字符 ，不会作变量的引用，直接输出字符窜。请看如下例子：\n [root@linux ~]# name=HaHa [root@linux ~]# echo $name HaHa [root@linux ~]# myname=\u0026quot;$name is wow\u0026quot; [root@linux ~]# echo $myname HaHa is wow [root@linux ~]# myname='$name is wow' [root@linux ~]# echo $myname $name is wow  从上面例子可以看出,使用了单引号的时候，那么$name只是普通字符,直接输出而已！\n逐行读取文件  使用for循环来读取文件\nfor line in `cat file.txt` do echo $line done  注意:由于使用for来读入文件里的行时，会自动把空格和换行符作为一样分隔符，如果行里有空格的时候，输出的结果会很乱，所以只适用于行连续不能有空格或者换行符的文件\n  使用while循环读取文件\ncat file.txt |while read line do echo $line done  或者：\nwhile read line do echo $line done \u0026lt; file.txt  注意:由于使用while来读入文件里的行时，会整行读入，不会关注行的内容(空格..)，所以比for读文件有更好的适用性，推荐使用while循环读取文件\n   bash shell 脚本中常用隐含变量    隐含变量 含义     $0 当前执行的脚本或者命令名称   $1-$9 代表参数的位置. 举例 $1 代表第一个参数.   $# 脚本调用的参数的个数   $@ 所有参数的内容   $* 所有参数的内容   $$ 当前运行脚本的进程号   $? 命令执行后返回的状态   $! 后台运行的最后一个进程号    注意:\n$? 用于检查上一个命令执行是否正确(在Linux中，命令退出状态为0表示该命令正确执行，任何非0值表示命令出错)\n$$ 变量最常见的用途是用做暂存文件的名字以保证暂存文件不会重复\n$* 和 $@ 结果输出是一样的，但是在使用for循环，在使用 双引号(\u0026ldquo;\u0026rdquo;)引用时 \u0026rdquo;$*\u0026rdquo; 会输出成一个元素 而 \u0026rdquo;$@\u0026rdquo; 会按照每个参数是一个元素方式输出\n 请看测试例子\n#cat test.sh #!/bin/sh echo '\u0026quot;$@\u0026quot; output.....' for i in \u0026quot;$@\u0026quot; do echo $i done echo '\u0026quot;$*\u0026quot; output ....' for i in \u0026quot;$*\u0026quot; do echo $i done  输出结果\n#sh test.sh a b c d \u0026quot;$@\u0026quot; output..... a b c d \u0026quot;$*\u0026quot; output .... a b c d   从输出结果可以看出 \u0026ldquo;$*\u0026rdquo; 输出是一行 而 \u0026ldquo;$@\u0026rdquo; 输出则是四行\n 变量内容的删除与替换 我们在一些情况下，需要对变量中的字符窜进行查找删除或者替换，就需要使用下表列出的方法\n   变量设定方式 说明     ${变量#关键字} 若变量内容从头开始的资料符合‘关键字’，则将符合的最短资料删除   ${变量##关键字} 若变量内容从头开始的资料符合‘关键字’，则将符合的最长资料删除   ${变量%关键字} 若变量内容从尾向前的资料符合‘关键字’，则将符合的最短资料删除   ${变量%%关键字} 若变量内容从尾向前的资料符合‘关键字’，则将符合的最长资料删除   ${变量/旧字串/新字串} 若变量内容符合‘旧字串’则‘第一个旧字串会被新字串取代   ${变量//旧字串/新字串} 若变量内容符合‘旧字串’则‘全部的旧字串会被新字串取代    举例如下(删除字符窜中的某个字符):\n[root@linux ~]# export test_str=\u0026quot;/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin\u0026quot; [root@linux ~]# echo ${test_str#/*kerberos/bin:} /usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin  变量条件测试赋值 在某些时刻我们需要\u0026rsquo;判断\u0026rsquo;某个变量是否存在，若变量存在则将此变量值赋值给新的变量，若变量不存在则将其他值赋值给新的变量.\n   变量设定方式 str 未定义 str 为空字串 str 已赋值为非空字串     var=${str-expr} var=expr var= var=$str   var=${str:-expr} var=expr var=expr var=$str   var=${str+expr} var= var=expr var=expr   var=${str:+expr} var= var= var=expr   var=${str?expr} expr 输出至 stderr var= var=$str   var=${str:?expr} expr 输出至 stderr expr 输出至 stderr var=$str   var=${str=expr} var=expr var= var=$str   var=${str:=expr} var=expr var=expr var=$str    举例如下:\n[root@linux ~]# test_name=\u0026quot;\u0026quot; [root@linux ~]# test_name=${test_name-root} [root@linux ~]# echo $test_name \u0026lt;== 因为 test_name 被设定为空字符窜！所以当然还是保留为空字符窜！ [root@linux ~]# test_name=${test_name:-root} [root@linux ~]# echo $test_name root \u0026lt;== 加上‘:’后若变量内容为空或者是未设定，都能够以后面的内容替换！   基本上这种变量的测试也能够透过 shell script 内的 if...then... 来处理,不过通过上述提及的简单的方法来测试变量，是程序看起来更精简一些！\n shell 中分隔符 : 变量IFS 使用 shell脚本中，如果使用for循环一个字符窜的话，默认使用空格来分割字符窜. 还有前面所提到的 使用for循环逐行读取文件内容时候,文件行中如果有空格的话输出的结果也会变乱. 这个时候 使用 IFS 变量来设置特定的字符窜分割符来，达到输出正确的目的. 默认情况下 IFS 是使用 空格 \\t \\n 来作为默认的分割符的.\n我们将前面使用for逐行读取文件的例子 改进下就可以输出正确了,请看下面\n#!/bin/bash IFS_old=$IFS #将原IFS值保存，以便用完后恢复 IFS=$’\\n’ #更改IFS值为$’\\n’ for line in `cat file.txt` do echo $line done  file.txt 文件内容如下\n[root@linux]$ cat file.txt sdfsdfsdfsdf ssssss ssssss ssssss sssss sdfsdfsdfsdfsdf  执行测试程序 输出结果如下(正确输出)\n[root@linux]$ sh test.sh sdfsdfsdfsdf ssssss ssssss ssssss sssss sdfsdfsdfsdfsdf  如果未设置IFS变量,使用默认的IFS变量值 ,输出结果如下\n[root@linux]$ sh test.sh sdfsdfsdfsdf ssssss ssssss ssssss sssss sdfsdfsdfsdfsdf  从以上测试程序输出结果,可以根据自己的需求来设定 IFS变量,在举一个例子如下:\nwhile IFS=: read userName passWord userID groupID geCos homeDir userShell do echo \u0026quot;$userName -\u0026gt; $homeDir\u0026quot; done \u0026lt; /etc/passwd  shell 数组的使用 数组赋值方式:\n(1) array=(var1 var2 var3 ... varN) (2) array=([0]=var1 [1]=var2 [2]=var3 ... [n]=varN) (3) array[0]=var1 arrya[1]=var2 ... array[n]=varN  计算数组元素个数或者长度:\n(1) ${#array[@]} (2) ${#array[*]}  了解了数组基础语法，举例说明，请看:\n#!/bin/bash NAMESERVERS=(\u0026quot;ns1.www.net.\u0026quot; \u0026quot;ns2.www.net.\u0026quot; \u0026quot;ns3.www.net.\u0026quot;) # 得到数组长度 tLen=${#NAMESERVERS[@]} # 循环数组 for (( i=0; i\u0026lt;${tLen}; i++ )); do echo ${NAMESERVERS[$i]} done  在看一个复杂一点的例子,将文件内容读取到数组中:\n#!/bin/bash # 设置IFS将分割符 设置为 换行符(\\n) OLDIFS=$IFS IFS=$'\\n' # 读取文件内容到数组 fileArray=($(cat file.txt)) # restore it IFS=$OLDIFS tLen=${#fileArray[@]} # 循环显示文件内容 for (( i=0; i\u0026lt;${tLen}; i++ )); do echo \u0026quot;${fileArray[$i]}\u0026quot; done  逻辑判断 条件测试 文件属性的判断    操作符 测试结果     -e filename 文件存在返回1， 否则返回0   -r filename 文件可读返回1,否则返回0   -w filename 文件可写返回1,否则返回0   -x filename 文件可执行返回1,否则返回0   -o filename 文件属于用户本人返回1, 否则返回0   -z filename 文件长度为0返回1, 否则返回0   -f filename 文件为普通文件返回1, 否则返回0   -d filename 文件为目录文件时返回1, 否则返回0    举例如下,测试文件是否存在:\n#!/bin/bash echo \u0026quot;checks the existence of the messages file.\u0026quot; echo -n \u0026quot;Checking...\u0026quot; if [ -f /var/log/messages ];then echo \u0026quot;/var/log/messages exists.\u0026quot; fi echo echo \u0026quot;...done.\u0026quot;  字符串比较    操作符 比较结果     str1 = str2 当两个字串相等时为真   str1 != str2 当两个字串不等时为真   -n str1 当字符串的长度大于0时为真   -z str1 当字符串的长度为0时为真   str 当字符串为非空时为真    举例如下,比较字符串来测试用户ID :\nif [ \u0026quot;$(whoami)\u0026quot; != 'root' ]; then echo \u0026quot;You have no permission to run $0 as non-root user.\u0026quot; exit 1; fi  数值比较(整数)    操作符 比较结果     num1 -eq num2 两数相等为真   num1 -ne num2 两数不等为真   num1 -gt num2 num1大于num2为真   num1 -ge num2 num1大于等于num2为真   num1 -lt num2 num1小于num2为真   num1 -le num2 num1小于等于num2为真    举例如下:\nnum=`wc -l work.txt` if [ $num -gt 150 ];then echo \u0026quot;you've worked hard enough for today.\u0026quot; echo fi  如果要查看详细的测试操作,可以查看man手册 man test\n"
},
{
	"uri": "/docs/devops/git_useage_qa/",
	"title": "Git使用常见问题",
	"tags": [],
	"description": "",
	"content": "    版本 日期 状态 修订人 摘要     V1.1 2018-01-02 创建 HunterFu 初始版本    使用git pull文件时和本地文件冲突怎么办？ 同事在使用git pull代码时，经常会碰到有冲突的情况，提示如下信息：\nerror: Your local changes to 'c/environ.c' would be overwritten by merge. Aborting. Please, commit your changes or stash them before you can merge.  这个意思是说更新下来的内容和本地修改的内容有冲突，先提交你的改变或者先将本地修改暂时存储起来。\n处理的方式非常简单，主要是使用git stash命令进行处理，分成以下几个步骤进行处理。\n 先将本地修改存储起来 $ git stash 这样本地的所有修改就都被暂时存储起来\n 用git stash list可以看到保存的信息： git stash list 结果如下 其中 stash@{0} 就是刚才保存的标记。\n 同步仓库内容(pull) 暂存了本地修改之后，就可以pull了。 $ git pull\n 还原暂存的内容 $ git stash pop stash@{0} 系统提示如下类似的信息：\nAuto-merging c/environ.c CONFLICT (content): Merge conflict in c/environ.c  意思就是系统自动合并修改的内容，但是其中有冲突，需要解决其中的冲突。\n 解决文件中冲突的的部分 打开冲突的文件，会看到类似如下的内容： 其中:\nUpdated upstream 和 =====之间的内容就是pull下来的内容\n==== 和 stashed changes 之间的内容就是本地修改的内容\n碰到这种情况，git也不知道哪行内容是需要的，所以要自行确定需要的内容。 解决完成之后，就可以正常的提交了。\n  已经在git仓库中的文件，清除跟踪状态 执行git rm --cached logs/xx.log命令即可\n需要注意的，git rm \u0026ndash;cached 删除的是追踪状态，而不是物理文件；如果你真的是彻底不想要了，你也可以直接 rm＋忽略＋提交\n修正 .gitignore 文件 忽略不需要跟踪的文件或者目录\n"
},
{
	"uri": "/docs/monitor/",
	"title": "监控系统",
	"tags": [],
	"description": "",
	"content": " 监控系统 Zabbix Zabbix 本分类主要讲述 Zabbix 监控系统相关配置等实践\n"
},
{
	"uri": "/docs/bigdata/",
	"title": "大数据",
	"tags": [],
	"description": "",
	"content": " 大数据Spark BigData 本分类主要讲述大数据相关配置等实践\n"
},
{
	"uri": "/docs/security/",
	"title": "信息安全",
	"tags": [],
	"description": "",
	"content": " 信息安全 Security 本分类主要讲述信息安全配置等实践\n"
},
{
	"uri": "/docs/devops/",
	"title": "开发运维",
	"tags": [],
	"description": "",
	"content": " 开发运维 DevOps 本分类主要讲述DevOps相关实践\n"
},
{
	"uri": "/docs/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/docs/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/docs/",
	"title": "技术文档",
	"tags": [],
	"description": "",
	"content": " 关于技术文档 这里文档都是日常运维中的点滴积累，有些已经是比较完善的文档，方便大家互相参考学\n主要内容分类  私有云的建设和应用,这里以CLOUDSTACK为基础IAAS平台 容器云的建设和应用,这里以Openshift Origin平台为基础 监控系统的建设和应用,主要以Zabbix为核心监控及二次开发相关 大数据相关系统, 如Hadoop、Spark、Kafka、Storm等,涉及到一些BI(商业智能)等 信息安全涉及到一些方法论和开源工具的使用等 开发运维(DevOps) 相关的技术点滴和CI/CD相关实践  问题反馈 在看文档过程中，有任何问题，请到这里留言反馈，谢谢。\n我们会在第一时间响应回复\n 开源方案应用 如果在真实的生产工作中，您有应用比较好的方案，可以推荐给我们，包括解决的问题，使用的场景等等，我们会推广给更多的用户，让更多的用户受益于开源方案 请到这里推荐反馈\n推荐的开源方案，最好是目前正在使用的，解决了那些问题，也希望给出优点和劣势\n "
}]