[
{
	"uri": "/docs/devops/mysql/",
	"title": "Mysql常用用法总结",
	"tags": [],
	"description": "",
	"content": "    版本 日期 状态 修订人 摘要     V1.0 2016-03-28 创建 HunterFu 创建文档    在日常工作中，会简单的使用一下mysql,故对常见命令操作总结一下，常用方式如下\nmysqldump 命令的使用  备份和导出数据库\nmysqldump -h database_ip -u Username -p --opt databasename \u0026gt; backup-file.sql  只导出数据库表结构\nmysqldump -h database_ip -d -u Username -p databasename \u0026gt;database_structure.sql  只导出数据库中的某个表\nmysqldump --opt --add-drop-table -u Username -p databasename tablename \u0026gt; dump.sql  如果不想手工输入密码 请使用--password 参数\nmysqldump -h database_ip -u Username --password=123456 --opt databasename \u0026gt; backup-file.sql mysqldump -h database_ip -d -u Username --password=123456 databasename \u0026gt;database_structure.sql  修改root用户密码\nmysqladmin -u root password \u0026quot;123456\u0026quot;   mysql 命令使用  将查询结果保存到文件\nselect title from book into outfile '/tmp/outfile.txt';  查找表中多余的重复记录，重复记录是根据某个字段（peopleId）来判断\nselect * from people where peopleId in (select peopleId from people group by peopleId having count(peopleId) \u0026gt; 1);  查询表中不重复记录(排除重复记录)\nselect * from phome_ecms_wma where title in (select distinct title from phome_ecms_wma);  删除表中重复记录,重复记录是根据某个字段（title）来判断\nselect *,count(distinct title) INTO OUTFILE '/tmp/table.bak' from phome_ecms_wma group by title; delete from phome_ecms_wma; LOAD DATA INFILE '/tmp/table.bak' REPLACE INTO TABLE phome_ecms_wma character set utf8;  随机选取记录\nmysql\u0026gt; SELECT *FROM url ORDER BY RAND() LIMIT 5;  查询数据库当前编码\nmysql\u0026gt; show variables like \u0026quot;character_set%\u0026quot;;  修改表字段类型\nmysql\u0026gt; alter table table_name change last_action last_action datetime NOT NULL default '0000-00-00 00:00:00';  给表添加一个新字段\nmysql\u0026gt; ALTER TABLE host ADD ks_mac VARCHAR(100);  从表中删除一个字段\nmysql\u0026gt; ALTER TABLE table_name DROP field_name;  重命名表\nmysql\u0026gt;alter table t1 rename t2;  给字段加索引\nmysql\u0026gt; alter table tablename add index 索引名 (字段名1[，字段名2 …]); mysql\u0026gt; alter table tablename add index emp_name (name);  加主关键字的索引\nmysql\u0026gt; alter table tablename add primary key(id);  加唯一限制条件的索引\nmysql\u0026gt; alter table tablename add unique emp_name2(cardnumber);  删除某个索引\nmysql\u0026gt;alter table tablename drop index emp_name;  远程访问mysql 设置(单独一个IP)\nmysql\u0026gt; CREATE DATABASE IF NOT EXISTS database_test; mysql\u0026gt; GRANT ALL PRIVILEGES ON database_test.* to root@192.168.1.9 IDENTIFIED BY '123456'; mysql\u0026gt; FLUSH PRIVILEGES;  授权远程访问(一个网段)\nmysql\u0026gt; grant all privileges on *.* to root@'192.168.124.%' identified by '123456'; mysql\u0026gt; FLUSH PRIVILEGES;   shell 命令中 mysql 使用 mysql -u root -p -e 'CREATE DATABASE IF NOT EXISTS database_test;' mysql -u root -p -e \u0026quot;GRANT ALL PRIVILEGES ON database_test.* to root@'%' IDENTIFIED BY '123456';\u0026quot;  "
},
{
	"uri": "/docs/cloudstack/",
	"title": "私有云",
	"tags": [],
	"description": "",
	"content": " 私有云 CloudStack CloudStack 本分类主要讲述 cloudstack 相关配置等实践\n"
},
{
	"uri": "/docs/devops/python_tips/",
	"title": "Python脚本知识总结",
	"tags": [],
	"description": "",
	"content": "    版本 日期 状态 修订人 摘要     V1.0 2016-03-28 创建 HunterFu 创建文档   V1.1 2017-08-07 修订 HunterFu 增加 指定占位符宽度(左对齐)    数据对象持久化 在某些时候，需要将数据对象的内容保存下来，方便下次程序启动时读取，这个就需要将对象持久化，请看如下例子\nimport pickle # create the test dictionary before_d = {} before_d[1]=\u0026quot;Name 1\u0026quot; before_d[2]=\u0026quot;Name 2\u0026quot; before_d[3]=\u0026quot;Name 3\u0026quot; # pickle dump the dictionary fout = open(\u0026quot;dict1.dat\u0026quot;, \u0026quot;w\u0026quot;) pickle.dump(before_d, fout, protocol=0) fout.close() # pickle load the dictionary fin = open(\u0026quot;dict1.dat\u0026quot;, \u0026quot;r\u0026quot;) after_d = pickle.load(fin) fin.close() print( before_d ) # {1: 'Name 1', 2: 'Name 2', 3: 'Name 3'} print( after_d ) # {1: 'Name 1', 2: 'Name 2', 3: 'Name 3'}  可以看出，我们将数据对象内容以文件的方式保存，可以作一些简单的cache处理，尤其是在写一些比较小的程序时，非常有用\n正则表达式替换 目标: 将字符串line中的 overview.gif 替换成其他字符串\n\u0026gt;\u0026gt;\u0026gt; line = '\u0026lt;IMG ALIGN=\u0026quot;middle\u0026quot; SRC=\u0026quot;overview.gif\u0026quot; BORDER=\u0026quot;0\u0026quot; ALT=\u0026quot;\u0026quot;\u0026gt;' \u0026gt;\u0026gt;\u0026gt; mo=re.compile(r'(?\u0026lt;=SRC=)\u0026quot;([\\w+\\.]+)\u0026quot;',re.I) \u0026gt;\u0026gt;\u0026gt; mo.sub(r'\u0026quot;\\1****\u0026quot;',line) '\u0026lt;IMG ALIGN=\u0026quot;middle\u0026quot; SRC=\u0026quot;cdn_overview.gif****\u0026quot; BORDER=\u0026quot;0\u0026quot; ALT=\u0026quot;\u0026quot;\u0026gt;' \u0026gt;\u0026gt;\u0026gt; mo.sub(r'replace_str_\\1',line) '\u0026lt;IMG ALIGN=\u0026quot;middle\u0026quot; SRC=replace_str_overview.gif BORDER=\u0026quot;0\u0026quot; ALT=\u0026quot;\u0026quot;\u0026gt;' \u0026gt;\u0026gt;\u0026gt; mo.sub(r'\u0026quot;testetstset\u0026quot;',line) '\u0026lt;IMG ALIGN=\u0026quot;middle\u0026quot; SRC=\u0026quot;testetstset\u0026quot; BORDER=\u0026quot;0\u0026quot; ALT=\u0026quot;\u0026quot;\u0026gt;'  注意: 其中 \\1 是匹配到的数据，可以通过这样的方式直接引用\n遍历目录方法 在某些时候，我们需要遍历某个目录找出特定的文件列表，可以通过os.walk方法来遍历,非常方便\nimport os fileList = [] rootdir = \u0026quot;/tmp\u0026quot; for root, subFolders, files in os.walk(rootdir): if '.svn' in subFolders: subFolders.remove('.svn') # 排除特定目录 for file in files: if file.find(\u0026quot;.t2t\u0026quot;) != -1:\t# 查找特定扩展名的文件 file_dir_path = os.path.join(root,file) fileList.append(file_dir_path) print fileList  列表按列排序(list sort) 如果列表的每个元素都是一个元组(tuple),我们要根据元组的某列来排序的化，可参考如下方法\n下面例子我们是根据元组的第2列和第3列数据来排序的,而且是倒序(reverse=True)\n\u0026gt;\u0026gt;\u0026gt; a = [('2011-03-17', '2.26', 6429600, '0.0'), ('2011-03-16', '2.26', 12036900, '-3.0'), ('2011-03-15', '2.33', 15615500,'-19.1')] \u0026gt;\u0026gt;\u0026gt; print a[0][0] 2011-03-17 \u0026gt;\u0026gt;\u0026gt; b = sorted(a, key=lambda result: result[1],reverse=True) \u0026gt;\u0026gt;\u0026gt; print b [('2011-03-15', '2.33', 15615500, '-19.1'), ('2011-03-17', '2.26', 6429600, '0.0'), ('2011-03-16', '2.26', 12036900, '-3.0')] \u0026gt;\u0026gt;\u0026gt; c = sorted(a, key=lambda result: result[2],reverse=True) \u0026gt;\u0026gt;\u0026gt; print c [('2011-03-15', '2.33', 15615500, '-19.1'), ('2011-03-16', '2.26', 12036900, '-3.0'), ('2011-03-17', '2.26', 6429600, '0.0')]  列表去重(list uniq) 有时候需要将list中重复的元素删除，就要使用如下方法\n\u0026gt;\u0026gt;\u0026gt; lst= [(1,'sss'),(2,'fsdf'),(1,'sss'),(3,'fd')] \u0026gt;\u0026gt;\u0026gt; set(lst) set([(2, 'fsdf'), (3, 'fd'), (1, 'sss')]) \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; lst = [1, 1, 3, 4, 4, 5, 6, 7, 6] \u0026gt;\u0026gt;\u0026gt; set(lst) set([1, 3, 4, 5, 6, 7])  字典排序(dict sort) 一般来说，我们都是根据字典的key来进行排序，但是我们如果想根据字典的value值来排序，就使用如下方法\n\u0026gt;\u0026gt;\u0026gt; from operator import itemgetter \u0026gt;\u0026gt;\u0026gt; aa = {\u0026quot;a\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;sss\u0026quot;:\u0026quot;2\u0026quot;,\u0026quot;ffdf\u0026quot;:'5',\u0026quot;ffff2\u0026quot;:'3'} \u0026gt;\u0026gt;\u0026gt; sort_aa = sorted(aa.items(),key=itemgetter(1)) \u0026gt;\u0026gt;\u0026gt; sort_aa [('a', '1'), ('sss', '2'), ('ffff2', '3'), ('ffdf', '5')]  从上面的运行结果看到，按照字典的value值进行排序的\n字典,列表,字符串互转  以下是生成数据库连接字符串,从字典转换到字符串\n\u0026gt;\u0026gt;\u0026gt; params = {\u0026quot;server\u0026quot;:\u0026quot;mpilgrim\u0026quot;, \u0026quot;database\u0026quot;:\u0026quot;master\u0026quot;, \u0026quot;uid\u0026quot;:\u0026quot;sa\u0026quot;, \u0026quot;pwd\u0026quot;:\u0026quot;secret\u0026quot;} \u0026gt;\u0026gt;\u0026gt; [\u0026quot;%s=%s\u0026quot; % (k, v) for k, v in params.items()] ['server=mpilgrim', 'uid=sa', 'database=master', 'pwd=secret'] \u0026gt;\u0026gt;\u0026gt; \u0026quot;;\u0026quot;.join([\u0026quot;%s=%s\u0026quot; % (k, v) for k, v in params.items()]) 'server=mpilgrim;uid=sa;database=master;pwd=secret'  下面的例子 是将字符串转化为字典\n\u0026gt;\u0026gt;\u0026gt; a = 'server=mpilgrim;uid=sa;database=master;pwd=secret' \u0026gt;\u0026gt;\u0026gt; aa = {} \u0026gt;\u0026gt;\u0026gt; for i in a.split(';'):aa[i.split('=',1)[0]] = i.split('=',1)[1] ... \u0026gt;\u0026gt;\u0026gt; aa {'pwd': 'secret', 'database': 'master', 'uid': 'sa', 'server': 'mpilgrim'}   时间对象操作  将时间对象转换成字符串\n\u0026gt;\u0026gt;\u0026gt; import datetime \u0026gt;\u0026gt;\u0026gt; datetime.datetime.now().strftime(\u0026quot;%Y-%m-%d %H:%M\u0026quot;) '2011-01-20 14:05'  时间大小比较\n\u0026gt;\u0026gt;\u0026gt; import time \u0026gt;\u0026gt;\u0026gt; t1 = time.strptime('2011-01-20 14:05',\u0026quot;%Y-%m-%d %H:%M\u0026quot;) \u0026gt;\u0026gt;\u0026gt; t2 = time.strptime('2011-01-20 16:05',\u0026quot;%Y-%m-%d %H:%M\u0026quot;) \u0026gt;\u0026gt;\u0026gt; t1 \u0026gt; t2 False \u0026gt;\u0026gt;\u0026gt; t1 \u0026lt; t2 True  时间差值计算,计算8小时前的时间\n\u0026gt;\u0026gt;\u0026gt; datetime.datetime.now().strftime(\u0026quot;%Y-%m-%d %H:%M\u0026quot;) '2011-01-20 15:02' \u0026gt;\u0026gt;\u0026gt; (datetime.datetime.now() - datetime.timedelta(hours=8)).strftime(\u0026quot;%Y-%m-%d %H:%M\u0026quot;) '2011-01-20 07:03'  将字符串转换成时间对象\n\u0026gt;\u0026gt;\u0026gt; endtime=datetime.datetime.strptime('20100701',\u0026quot;%Y%m%d\u0026quot;) \u0026gt;\u0026gt;\u0026gt; type(endtime) \u0026lt;type 'datetime.datetime'\u0026gt; \u0026gt;\u0026gt;\u0026gt; print endtime 2010-07-01 00:00:00 \u0026gt;\u0026gt;\u0026gt;  将从 1970-01-01 00:00:00 UTC 到现在的秒数，格式化输出\n\u0026gt;\u0026gt;\u0026gt; import time \u0026gt;\u0026gt;\u0026gt; a = 1302153828 \u0026gt;\u0026gt;\u0026gt; time.strftime(\u0026quot;%Y-%m-%d %H:%M:%S\u0026quot;,time.localtime(a)) '2011-04-07 13:23:48'  将日期转换成秒数\n\u0026gt;\u0026gt;\u0026gt; endtime=datetime.datetime.strptime('20100701',\u0026quot;%Y%m%d\u0026quot;) \u0026gt;\u0026gt;\u0026gt; time.mktime(endtime.timetuple()) 1277913600.0  strptime | strftime 支持的时间格式化列表\n     格式化字符 意义     %a 星期几的简写 Weekday name, abbr.   %A 星期几的全称 Weekday name, full   %b 月分的简写 Month name, abbr.   %B 月份的全称 Month name, full   %c 标准的日期的时间串 Complete date and time representation   %d 十进制表示的每月的第几天 Day of the month   %H 24小时制的小时 Hour (24-hour clock)   %I 12小时制的小时 Hour (12-hour clock)   %j 十进制表示的每年的第几天 Day of the year   %m 十进制表示的月份 Month number   %M 十时制表示的分钟数 Minute number   %s seconds since 00:00:00 1970-01-01 UTC (a GNU extension)   %S 十进制的秒数 Second number   %U 第年的第几周，把星期日做为第一天（值从0到53）Week number (Sunday first weekday)   %w 十进制表示的星期几（值从0到6，星期天为0）weekday number   %W 每年的第几周，把星期一做为第一天（值从0到53） Week number (Monday first weekday)   %x 标准的日期串 Complete date representation (e.g. 13/01/08)   %X 标准的时间串 Complete time representation (e.g. 17:02:10)   %y 不带世纪的十进制年份（值从0到99）Year number within century   %Y 带世纪部分的十制年份 Year number   %Z 时区名称，如果不能得到时区名称则返回空字符。Name of time zone   %% 输出百分号    命令行参数解析(getopt) 通常在编写一些日运维脚本时，需要根据不同的条件，输入不同的命令行选项来实现不同的功能, 在Python中提供了getopt模块很好的实现了命令行参数的解析,下面距离说明。 请看如下程序:\n#!/usr/bin/env python # -*- coding: utf-8 -*- import sys,os,getopt def usage(): print ''' Usage: analyse_stock.py [options...] Options: -e : Exchange Name -c : User-Defined Category Name -f : Read stock info from file and save to db -d : delete from db by stock code -n : stock name -s : stock code -h : this help info test.py -s haha -n \u0026quot;HA Ha\u0026quot; ''' try: opts, args = getopt.getopt(sys.argv[1:],'he:c:f:d:n:s:') except getopt.GetoptError: usage() sys.exit() if len(opts) == 0: usage() sys.exit() for opt, arg in opts: if opt in ('-h', '--help'): usage() sys.exit() elif opt == '-d': print \u0026quot;del stock %s\u0026quot; % arg elif opt == '-f': print \u0026quot;read file %s\u0026quot; % arg elif opt == '-c': print \u0026quot;user-defined %s \u0026quot; % arg elif opt == '-e': print \u0026quot;Exchange Name %s\u0026quot; % arg elif opt == '-s': print \u0026quot;Stock code %s\u0026quot; % arg elif opt == '-n': print \u0026quot;Stock name %s\u0026quot; % arg sys.exit()  注意: 这里我们使用短格式分析串\u0026lsquo;he:c:f:d:n:s:\u0026rsquo;, 当一个选项只是表示开关状态时,即后面不带附加参数时,在分析串中写入选项字符\n当选项后面是带一个附加参数时，在分析串中写入选项字符同时后面加一个 : 冒号\n所以 \u0026lsquo;he:c:f:d:n:s:\u0026rsquo; 就表示 \u0026lsquo;h\u0026rsquo;是一个开关选项, \u0026lsquo;e:c:f:d:n:s:\u0026lsquo;则表示这些选项后面应该带一个参数.\nprint 格式化输出 格式化输出字符串  截取字符串输出,下面例子将只输出字符串的前3个字母\n\u0026gt;\u0026gt;\u0026gt; str=\u0026quot;abcdefg\u0026quot; \u0026gt;\u0026gt;\u0026gt; print \u0026quot;%.3s\u0026quot; % str abc  按固定宽度输出，不足使用空格补全,下面例子输出宽度为10\n\u0026gt;\u0026gt;\u0026gt; str=\u0026quot;abcdefg\u0026quot; \u0026gt;\u0026gt;\u0026gt; print \u0026quot;%10s\u0026quot; % str abcdefg  指定占位符宽度(左对齐)\n\u0026gt;\u0026gt;\u0026gt; print (\u0026quot;Name:%-10s Age:%-8d Height:%-8.2f\u0026quot;%(\u0026quot;Aviad\u0026quot;,25,1.83)) Name:Aviad Age:25 Height:1.83 \u0026gt;\u0026gt;\u0026gt;  截取字符串，按照固定宽度输出\n\u0026gt;\u0026gt;\u0026gt; str=\u0026quot;abcdefg\u0026quot; \u0026gt;\u0026gt;\u0026gt; print \u0026quot;%10.3s\u0026quot; % str abc  浮点类型数据位数保留\n\u0026gt;\u0026gt;\u0026gt; import fpformat \u0026gt;\u0026gt;\u0026gt; a= 0.0030000000005 \u0026gt;\u0026gt;\u0026gt; b=fpformat.fix(a,6) \u0026gt;\u0026gt;\u0026gt; print b 0.003000  对浮点数四舍五入,主要使用到round函数\n\u0026gt;\u0026gt;\u0026gt; from decimal import * \u0026gt;\u0026gt;\u0026gt; a =\u0026quot;2.26\u0026quot; \u0026gt;\u0026gt;\u0026gt; b =\u0026quot;2.29\u0026quot; \u0026gt;\u0026gt;\u0026gt; c = Decimal(a) - Decimal(b) \u0026gt;\u0026gt;\u0026gt; print c -0.03 \u0026gt;\u0026gt;\u0026gt; c / Decimal(a) * 100 Decimal('-1.327433628318584070796460177') \u0026gt;\u0026gt;\u0026gt; Decimal(str(round(c / Decimal(a) * 100, 2))) Decimal('-1.33') \u0026gt;\u0026gt;\u0026gt;   进制转换 有些时候需要作不同进制转换，可以参考下面的例子(%x 十六进制,%d 十进制,%o十进制)\n \u0026gt;\u0026gt;\u0026gt; num = 10 \u0026gt;\u0026gt;\u0026gt; print \u0026quot;Hex = %x,Dec = %d,Oct = %o\u0026quot; %(num,num,num) Hex = a,Dec = 10,Oct = 12  Python调用系统命令或者脚本  使用 os.system() 调用系统命令 , 程序中无法获得到输出和返回值\n\u0026gt;\u0026gt;\u0026gt; import os \u0026gt;\u0026gt;\u0026gt; os.system('ls -l /proc/cpuinfo') \u0026gt;\u0026gt;\u0026gt; os.system(\u0026quot;ls -l /proc/cpuinfo\u0026quot;) -r--r--r-- 1 root root 0 3月 29 16:53 /proc/cpuinfo 0  使用 os.popen() 调用系统命令, 程序中可以获得命令输出，但是不能得到执行的返回值\n\u0026gt;\u0026gt;\u0026gt; out = os.popen(\u0026quot;ls -l /proc/cpuinfo\u0026quot;) \u0026gt;\u0026gt;\u0026gt; print out.read() -r--r--r-- 1 root root 0 3月 29 16:59 /proc/cpuinfo \u0026gt;\u0026gt;\u0026gt;  使用 commands.getstatusoutput() 调用系统命令, 程序中可以获得命令输出和执行的返回值\n\u0026gt;\u0026gt;\u0026gt; import commands \u0026gt;\u0026gt;\u0026gt; commands.getstatusoutput('ls /bin/ls') (0, '/bin/ls') \u0026gt;\u0026gt;\u0026gt;   Python 捕获用户 Ctrl+C ,Ctrl+D 事件 有些时候，需要在程序中捕获用户键盘事件，比如ctrl+c退出，这样可以更好的安全退出程序\n try: do_some_func() except KeyboardInterrupt: print \u0026quot;User Press Ctrl+C,Exit\u0026quot; except EOFError: print \u0026quot;User Press Ctrl+D,Exit\u0026quot;  Python 读写文件  一次性读入文件到列表，速度较快，适用文件比较小的情况下\ntrack_file = \u0026quot;track_stock.conf\u0026quot; fd = open(track_file) content_list = fd.readlines() fd.close() for line in content_list: print line  逐行读入，速度较慢,适用没有足够内存读取整个文件(文件太大)\nfd = open(file_path) fd.seek(0) title = fd.readline() keyword = fd.readline() uuid = fd.readline() fd.close()   写文件 write 与 writelines 的区别\nFd.write(str) : 把str写到文件中，write()并不会在str后加上一个换行符\nFd.writelines(content) : 把content的内容全部写到文件中,原样写入，不会在每行后面加上任何东西\n Python 读取 YAML 配置文件 简单的配置文件范例 配置文件如下,一般YAML文件扩展名为.yaml:\n [root@localhost]# cat us-cdn.yaml templateName: \u0026quot;us-cdn\u0026quot; version: \u0026quot;0.1\u0026quot; actionsequence: - install - sync sync: - cmd: \u0026quot;svn export http://svn.test.com/\u0026quot; SuccessMsg: \u0026quot;OK\u0026quot; FailedMsg: \u0026quot;Run Cmd Error %s\u0026quot; install: - cmd: \u0026quot;yum install squid squid-script\u0026quot; SuccessMsg: \u0026quot;OK\u0026quot; FailedMsg: \u0026quot;Run Cmd Error %s\u0026quot;  从上面的配置文件来看，非常容易读懂和理解，层次关系也非常明了。\nPyYAML 模块来解析YAML配置文件 参考测试程序:\n [root@localhost]# cat test_yaml.py #!/usr/bin/env python # -*- coding: utf-8 -*- import os import yaml import sys from pprint import pprint base_dir = os.path.abspath(os.path.dirname(sys.argv[0])) configFile = \u0026quot;%s/%s\u0026quot; % (base_dir,\u0026quot;us-cdn.yaml\u0026quot;) stream = file(configFile, 'r') data = yaml.load(stream) pprint(data)  执行结果如下:\n [root@localhost]# python test_yaml.py {'actionsequence': ['install', 'sync'], 'install': [{'FailedMsg': 'Run Cmd Error %s', 'SuccessMsg': 'OK', 'cmd': 'yum install squid squid-script'}], 'sync': [{'FailedMsg': 'Run Cmd Error %s', 'SuccessMsg': 'OK', 'cmd': 'svn export http://svn.test.com/'}], 'templateName': 'us-cdn', 'version': '0.1'}  从执行结果可以看出,最终返回的是字典结构，你可以方便的引用。在写一些系统运维管理脚本的化，可以参考使用yaml格式的配置文件.\n常见问题 UnicodeDecodeError: \u0026lsquo;ascii\u0026rsquo; codec can\u0026rsquo;t decode byte 0xe8 in position 0: ordinal not in range(128) 程序加入如下3行，问题解决\nimport sys reload(sys) sys.setdefaultencoding('utf-8')  "
},
{
	"uri": "/docs/openshift/",
	"title": "容器云",
	"tags": [],
	"description": "",
	"content": " 容器云 OpenShift Origin OpenShift 本分类主要讲述 openshift origin 相关配置等实践\n"
},
{
	"uri": "/docs/monitor/",
	"title": "监控系统",
	"tags": [],
	"description": "",
	"content": " 监控系统 Zabbix Zabbix 本分类主要讲述 Zabbix 监控系统相关配置等实践\n"
},
{
	"uri": "/docs/bigdata/",
	"title": "大数据",
	"tags": [],
	"description": "",
	"content": " 大数据Spark BigData 本分类主要讲述大数据相关配置等实践\n"
},
{
	"uri": "/docs/security/",
	"title": "信息安全",
	"tags": [],
	"description": "",
	"content": " 信息安全 Security 本分类主要讲述信息安全配置等实践\n"
},
{
	"uri": "/docs/devops/",
	"title": "开发运维",
	"tags": [],
	"description": "",
	"content": " 开发运维 DevOps 本分类主要讲述DevOps相关实践\n"
},
{
	"uri": "/docs/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/docs/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/docs/",
	"title": "技术文档",
	"tags": [],
	"description": "",
	"content": " 关于技术文档 这里文档都是日常运维中的点滴积累，有些已经是比较完善的文档，方便大家互相参考学\n主要内容分类  私有云的建设和应用,这里以CLOUDSTACK为基础IAAS平台 容器云的建设和应用,这里以Openshift Origin平台为基础 监控系统的建设和应用,主要以Zabbix为核心监控及二次开发相关 大数据相关系统, 如Hadoop、Spark、Kafka、Storm等,涉及到一些BI(商业智能)等 信息安全涉及到一些方法论和开源工具的使用等 开发运维(DevOps) 相关的技术点滴和CI/CD相关实践  问题反馈 在看文档过程中，有任何问题，请到这里留言反馈，谢谢。\n我们会在第一时间响应回复\n 开源方案应用 如果在真实的生产工作中，您有应用比较好的方案，可以推荐给我们，包括解决的问题，使用的场景等等，我们会推广给更多的用户，让更多的用户受益于开源方案 请到这里推荐反馈\n推荐的开源方案，最好是目前正在使用的，解决了那些问题，也希望给出优点和劣势\n "
}]